{"pages":[],"posts":[{"title":"github搜索命令","text":"首先感谢CodeSheep和热评课代表|使用方法|描述||—-|—-|| in:name example | 名字中有“example” || in:readme example | readme中有“example” || in:description example | 描述中有“example” ||stars:&gt;1000|star&gt;1000||forks:&gt;1000|fork&gt;1000||pushed:&gt;2019-09-01|2019年9月1日后有更新的||language:java|用Java编写的项目|","link":"/2019/11/25/github搜索命令/"},{"title":"idea连接mysql错误","text":"尝试在idea上连接mysql，显示时区错误 解决：1.先要保证系统环境变量里有mysql2.cmd3.mysql -hlocalhost -uroot -p4.输入密码5.show variables like’%time_zone’;6.然后会显示时区为跟随系统7.set global time_zone = ‘+8:00’;8.转为东8区9.然后再次尝试连接数据库","link":"/2019/12/03/idea连接mysql错误/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/12/15/hello-world/"},{"title":"关于递归形成Jtree目录树","text":"找了一遍好像没找到关于形成递归形成Jtree目录树的文章，正好最近要用到，就写一篇博客来记录一些东西。边改边写吧，可能有一些错误。 首先需要用到 Sort.java 1234567891011121314151617181920212223public class Sort { private String sid; private String parent; public Sort(String id, String p) { setSid(id); setParent(p); } public String getSid() { return sid; } public void setSid(String sid) { this.sid = sid; } public String getParent() { return parent; } public void setParent(String parent) { this.parent = parent; }} Dao.java 12345678910111213141516171819202122//Dao类public class Dao { private ArrayList&lt;Sort&gt; list = new ArrayList&lt;Sort&gt;(); public Dao() { list.add(new Sort(\"001\", \"005\")); list.add(new Sort(\"002\", \"001\")); list.add(new Sort(\"003\", \"002\")); list.add(new Sort(\"004\", \"005\")); list.add(new Sort(\"005\", \"000\")); } public DefaultMutableTreeNode BuildTree(DefaultMutableTreeNode pNode){ DefaultMutableTreeNode cNode; for(Sort menuNode : list) { if(menuNode.getParent().equals(pNode.toString())) { cNode=new DefaultMutableTreeNode(menuNode.getSid()); pNode.add(cNode); BuildTree(cNode); } } return pNode; }} 然后Jtree的一些设置 123456789101112131415161718DefaultMutableTreeNode root;JTree tree;Dao treeDao = new Dao();// 初始化rootroot = new DefaultMutableTreeNode(\"000\");// 树进行初始化，其数据来源是root对象tree = new JTree(root);// 放入JScrollPane中js_West.setViewportView(tree);// 建立树treeDao.BuildTree(root);//设置监听tree.addTreeSelectionListener(new TreeSelectionListener() { @Override public void valueChanged(TreeSelectionEvent treeSelectionEvent) { System.out.println(\"你选择了：\" + tree.getLastSelectedPathComponent().toString()); }});","link":"/2019/10/24/关于递归形成Jtree目录树/"},{"title":"java关于连接池配置","text":"前几天在学java的数据库连接池，这里总结一下 一、需要先下载 https://sourceforge.net/projects/c3p0/ win用户选择/c3p0-bin/c3p0-0.9.5.4/c3p0-0.9.5.4.bin.zip linux用户选择/c3p0-bin/c3p0-0.9.5.4/c3p0-0.9.5.4.bin.tgz 然后如果使用mysql数据库，需要下载mysql-connector-java-5.1.48-bin.jar 二、然后解压导包这是c3p0 c3p0-0.9.5.4.jar 这是c3p0的依赖包 mchange-commons-java-0.2.15.jar mysql-connector-java-5.1.48-bin.jar 三、写c3p0-config.xml123456789101112131415&lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name=\"driverClass\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://127.0.0.1:3306/regsystem?user=root&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;XXXXXX&lt;/property&gt; &lt;property name=\"checkoutTimeout\"&gt;30000&lt;/property&gt; &lt;property name=\"idleConnectionTestPeriod\"&gt;30&lt;/property&gt; &lt;property name=\"initialPoolSize\"&gt;3&lt;/property&gt; &lt;property name=\"maxIdleTime\"&gt;30&lt;/property&gt; &lt;property name=\"maxPoolSize\"&gt;100&lt;/property&gt; &lt;property name=\"minPoolSize\"&gt;2&lt;/property&gt; &lt;property name=\"maxStatements\"&gt;200&lt;/property&gt; &lt;/default-config&gt;&lt;/c3p0-config&gt; 这是连接本地的mysql，修改url可以访问服务器段的mysql 四、连接我使用dbutils的QueryRunner来连接，比较方便 commons-dbutils-1.7.jar commons-logging-1.2.jar 1private QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); 这样写在类里面就可以用了 1234567891011121314151617181920212223242526//查找public List&lt;Student&gt; getList() { try { //sql语句 String sql = \"select * from student\"; //准备参数 Object[] params = {}; //执行 return queryRunner.query(sql,new BeanListHandler&lt;Student&gt;(Student.class),params); }catch (Exception e){ throw new RuntimeException(e); } }//删除public void delete(String id) { try { //sql语句s String sql = \"delete from notice where student = ?\"; //准备参数 Object[] params = {id}; //执行 queryRunner.update(sql,params); }catch (Exception e){ throw new RuntimeException(e); } } 这样就返回了List类型的数据库的内容了","link":"/2019/11/24/javaWeb关于C3P0连接池配置/"},{"title":"本地项目上传到github","text":"找到项目 git init 添加引索和说明 git add. git commit -m “XXX” 添加地址 git remote add origin https://github.com/XXX 上传 git push git还有一些其他操作就下次再说","link":"/2019/12/14/本地项目上传到github/"},{"title":"云主机部署Tomcat服务器","text":"我在学习javaweb后对javaweb发布的一些尝试，使用阿里云主机，安装jdk11，tomcat9和mysql，并成功跑起来 购买云主机搜索云翼计划，https://promotion.aliyun.com/ntms/act/campus2018.html选则购买轻量应用服务器9.5/月预装Ubuntu 16.04 64位地域华东二上海，选近的就是了，然后是付款付款付款，支付成功后进入 管理控制台 Xshell和XftpXftp：https://www.netsarang.com/zh/downloading/?token=cjR0UzNEUEFZdUlLRHFBelBYNkxpd0A0bFhJbnJaY2FrZ242OE4wX29oQVpR Xshell：https://www.netsarang.com/zh/downloading/?token=V2Z0VmpGdUNtbkRKU2FwMUc1TG93Z0A0bFhJbnJaY2FrZ242OE4wX29oQVpR 配置Xshell和Xftp将云主机公网ip配置到Xshell和Xftp中 连接主机 部署jdk更新源1sudo apt-get update 安装jdk1sudo apt-get install openjdk-8-jdk 一站式安装轻轻松松，无需配置，用下面的命令查看是否安装成功 1java -version 安装tomcat下载安装包从tomcat官网下载.tar.gzd的安装包 https://tomcat.apache.org/download-90.cgi 通过Xftp拖进去，也可以在Ubuntu里直接下载，我放这个目录下 1cd /usr/ 解压然后解压，个人喜好最新版，虽然可能不稳定 1sudo tar -xvzf apache-tomcat-9.0.29.tar.gz 开启服务然后去开启服务 12cd /apache-tomcat-9.0.29/bin./startup.sh 在本地访问http://公网ip:8080 就能看到tomcat的页面 若是访问失败可能是阿里云的防火墙需要新增规则 自定义，TCP，8080 然后就可以再次访问就可以了 然后tomcat安装结束 Mysql安装开始安装123sudo apt-get install mysql-serversudo apt-get isntall mysql-clientsudo apt-get install libmysqlclient-dev 安装结束，其中需要输入密码，就是数据库的密码 若没有让你输入密码，就有点麻烦了，具体请百度 开启数据库1service mysql start 关闭数据库 1service mysql stop 登录数据库,然后就能进行各种操作了 1mysql -u root -p 部署网站，上传war包准备war包先在项目里创建war包 将项目war包利用Xftp传到tomcat的webapps目录下 启动tomcat然后重启tomcat，war包自动解压 只要你的项目没问题，war包没问题 然后就输入ip地址和项目包名就可以正常访问了 mysql的一些问题改文件先要注释掉bind-address=127.0.0.1 打开这个文件 1vim /etc/mysql/mysql.conf.d/mysqld.cnf 然后找到bind-address=127.0.0.1把他注释掉 vim的操作就不多说了 mysql配置然后登录mysql 1mysql -u root -p 输入密码，然后运行 123456789show databases;use mysql;update user set host=&apos;%&apos; where user=&apos;root&apos; and host=&apos;localhost&apos;; #将host设置为%表示任何ip都能连接mysql，当然您也可以将host指定为某个ipflush privileges; #刷新权限表使之生效exit; #退出去 启动mysql然后启动mysql 1service mysql restart 阿里云配置然后再阿里云那边的防火墙新增规则 开发端口3306至此本地的sql客户端能连到云主机的mysql","link":"/2019/11/23/云主机部署Tomcat服务器/"},{"title":"","text":"表/模式的建立和删除1.创建模式1create schema \"S-T\" authorization WANG; /*为用户WANG定义一个学生-课程模式S-T*/ //没有写模式名默认用户名 2.创建表1234567create table TAB1(col1 smallint, col2 int, col3 char(20), col4 numeric(10,3), col5 decimal(5,2) );create table \"S-T\".SC(); /*SC表所属的模式为S-T*/ 3.删除1234drop schema ZHANG &lt;cascade|restrict&gt;;/*删除模式ZHANG，cascade表示删除模式并把模式中的所有数据库都删除，restrict表示只有该模式下没有数据库才能删除*/drop table STU [cascade|restrict];/*删除表STU，cascade表示删除表所有相关的内容，restrict表示此表没有外面相联系的内容时才能删除*/ 4.定义基本表1234567create table STU( Sno char(9) primary key, /*Sno为主码，列级完整性约束条件*/ Sname char(20) unique, /*取唯一值*/ Ssex char(2) not null, /*不能取空*/ Spno char(4), foreign key(Spno) references COURSE(Cpno)/* 表级完整性约束条件，Spno为外码，被参照表为COURSE，参照列是Cpno*/ ); //参照表和被参照表可以是同一张 5.显示搜索路径12show search_path;set search_path to \"S-T\", public;/*管理员可以设置搜索路径，然后再建立基本表，那么基本表模式为S-T*/ //搜索路径包含模式列表 6.修改基本表123alter table STU add S_time date; /*为STU表新增S_time列，数据类型为date*/alter table STU alter column S_time int; /*将S_time的数据类型改成int*/alter table STU add unique(S_time); /*为S_time添加约束条件*/ 7.索引1234567/*创建索引*/create unique index AAA on STU(Sno); /*按Sno升序建立唯一索引*/create unique index BBB on SC(Sno ASC, Cno DESC); /*SC表按Sno升序和Cno降序建立唯一索引*//*修改索引*/alter index SCNO rename to SCSNO; /*将索引SCNO改名为SCSNO*//*删除索引*/drop index SCSNO; /*删除SCSNO索引*/ //ASC升序，DESC降序 数据查询1.单表查询123456select Sno from STU; /*查询STU表中的Sno*/select all Sno from STU;select * from STU; /*查询全部*/select distinct Sno from STU;/*消除重复行*/select Sname,Sage from STU where Sage between 20 and 30;/*20-30岁的学生*/select Sname,Sage from STU where Sage between 20 and 30 order by Sage desc;/*降序表示*/ 2.聚集函数123456789101112131415/*查询总人数*/select count(*)from STU;/*查询不同Sno的人数*/select count(distinct Sno)from STU;/*选修a课程的平均成绩*/select avg(grade)from STUwhere Cno = 'a';/*搜索后的数据按某一列相同组的分一起*/select Cno,count(Sno)from STUgroup by Cnohaving count(*)&gt;3;/*选出所有人中大于3的人*/ 3.连接查询12345/*连接两个表*/select STU.*,SC.*from STU,SCwhere STU.Sno = SC.Sno;/*去掉重复属性：自然连接*/ 数据更新1.插入数据12insert into STU(Sno,Sname,Ssex) values ('001','A','男'); /*将后面的信息插入到STU中*/insert into STU values ('001','A','男'); /*这样也可以插入，但是会有一些小问题*/ 2.修改数据12update STU set Sname = '233' where Sno = '001'; /*将001的数据的Sname值改成233*/update STU set Sage = Sage + 1; /*将所有Sage增加1*/ 3.删除数据12delete from STU where Sno = '001'; /*删除001的记录*/delete from STU; /*删除STU所有记录*/ 空值不知道填什么可以用NULL代替 1update STU set Sdept = NULL; /*将Sdept设为空*/ 判断是否为空 is NULL或者is not NULL 视图1.建立视图123456create view VIEWNAME /*创建视图*/asselect Sno,Sname,Sage /*选择3列*/from STUwhere Sdept='IS'with check option; /*之后对视图进行操作时，系统会自动加上Sdept='is'的条件*/ 行列子集视图：从基本表中导出，只是去掉了某些行列，但保留主码 2.删除视图123drop view VIEWNAME [cascade]; /*1.删除基本表，但是没有删除视图，只是删除数据。 2.加cascade会删除由此视图导出的所有视图。*/ 3.查询视图1select Sno,Sage from VIEWNAME where Sage &lt; 20; /*找出年龄小于20岁的学生*/ 4.更新视图1234567update VIEWNAMEset Sname = 'AAA'where Sno = '001'/*尽量不要改变视图，上面是改变视图，下面是改变表*/update STUset Sname = 'AAA'where Sno = '001' AND Sdept = 'IS';","link":"/2020/01/06/数据库语法/"},{"title":"汇编语言笔记","text":"汇编语言的课堂笔记 第二章8086： 字长16位 数据总线16位 地址总线20位，可以确定寻址空间 寻址空间1MB = 2^20^B = 2^16^*2^4^ 双字 计算机结构： 运算器 控制器 存储器 I/O设备 寄存器 寄存器：通用寄存器 数据寄存器：AX，BX，CX，DX（可16位可8位访问） 每个名称前面加E，表示32位 AH，BH，CH，DH表示16位，AL，BL，CL，DL表示8位 AX：累加器 BX：基址变址 CX：计数 DX：数据 变址寄存器：SP，BP，SI，DI（可16位访问） SP：堆栈指针寄存器：栈顶偏移地址 BP：基址指针寄存器：堆栈基地址 SI：源变址寄存器 DI：目的变址寄存器 #### 专用寄存器 IP，SP，FLAGS（可16位访问） IP：指令指针寄存器：始终指向下一条指令的首地址 SP：堆栈指针寄存器：存放栈顶的偏移地址 FLAGS：标志寄存器：存放条件码标志，控制标志，系统标志 条件标志 OF：溢出标志，1为溢出 SF：符号标志，1为负号 ZF：零标志，1为结果为零 CF：进位标志，1为有效进位 AF：辅助进位标志，1为第三位有进位时 PF：奇偶标志，1为偶数 控制标志 DF：方向标志，1为使得变址寄存器SI和DI减小，从高地址向低地址方向处理 系统标志 TF：陷阱标志，1为产生陷阱，用于调试 IF：中断标志，1为允许CPU响应可屏蔽中断请求 #### 段寄存器 确定一个段的起始地址，一般占用64KB存储区 CS，DS，ES，SS（可16位访问） CS：代码段寄存器 DS：数据段寄存器：16位寻址 ES：附加段寄存器 SS：堆栈段寄存器：32位寻址 FS，GS无专用名称 存储器8086为双字 = 4个字节 = 32位 = 低位字16位+高位字16位 20位地址总线能够表示的地址范围：00000——FFFFFH 从小到大排，从大到小读 计算：段地址左移四位加上偏移地址 第三章数据相关寻址方式1.立即寻址方式12MOV AL,5 /*执行后(AL)=05H*/MOV AX,3064H /*执行后(AX)=3064H*/ 2.寄存器寻址方式1MOV AX, BX /*将BX中的内容放到AX中*/ 有效地址：EA = 基址 + （变址 * 比例因子）+ 位移量 不能使用跨越前缀 串处理指令的目的串必须用ES段 PUSH指令的目的和POP指令的源必须使用SS段 指令必须存放在CS段 3.直接寻址方式1MOV AX, [2000H] /*(DS)=3000H时，则实际地址为32000H，AX的内容为32000H地址内的内容(16位)*/ 4.寄存器间接寻址方式1MOV AX, [BX] /*(DS)=2000H,(BH)=1000H,物理地址为21000H，AX的内容为21000H地址中的内容(16位)*/ 5.寄存器相对寻址方式1MOV AX, COUNT[SI] /*(DS)=3000H,(SI)=2000H,COUNT=3000H,物理地址为35000H，AX的内容为35000H地址中的内容(16位)*/ 6.基址变址寻址方式1MOV AX, [BX][DI] /*(DS)=2100H,(BX)=0158H,DI=10A5H,物理地址为221FDH，AX的内容为221FDH地址中的内容(16位)*/ 7.相对基址变址寻址方式1MOV AX, MASK[BX][SI] /*(DS)=3000H,(BX)=2000H,SI=1000H,MASK=0250H,物理地址为33250H，AX的内容为33250H地址中的内容(16位)*/ 8.比例变址寻址方式9.基址比例变址寻址方式10.相对基址比例变址寻址方式转移地址相关寻址方式1.段内直接寻址123/*只有这个能进行条件转移*/JMP NEAR PTR PROGIA /*条件转移，PROGIA为符号地址，用位移量表示，NEAR PTR为16位位移量*/JMP SHORT QUEST /*无条件转移，QUEST为符号地址，用位移量表示，SHORT为8位位移量*/ 2.段内间接寻址123JMP BX /*(BX)=1256H,则(IP)=1256H*/ JMP WORD PTR[BP+TABLE] /*WORD PTR为操作符，用来说明后面的地址是一个字的有效地址*/JMP TABLE[BX] /*(DS)=2000H,(BX)=1256H,位移量=20A1H,(232F7H)=3280H,则(IP)=(20000+1256+20A1)=(232F7)=3280H*/ 3.段间直接寻址4.段间间接寻址指令系统123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285---------- 一、数据传输指令 ---------------------------------------------------- 它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据. 1. 通用数据传送指令. MOV 传送字或字节. MOVSX 先符号扩展,再传送. MOVZX 先零扩展,再传送. PUSH 把字压入堆栈. POP 把字弹出堆栈. PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈. POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈. PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈. POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈. BSWAP 交换32位寄存器里字节的顺序 XCHG 交换字或字节.(至少有一个操作数为寄存器,段寄存器不可作为操作数) CMPXCHG 比较并交换操作数.(第二个操作数必须为累加器AL/AX/EAX) XADD 先交换再累加.(结果在第一个操作数里) XLAT 字节查表转换.----BX指向一张256字节的表的起点,AL为表的索引值(0-255,即0-FFH);返回AL为查表结果.([BX+AL]-&gt;AL) 2. 输入输出端口传送指令. IN I/O端口输入. ( 语法: IN 累加器, {端口号│DX} ) OUT I/O端口输出. ( 语法: OUT {端口号│DX},累加器 )输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时,其范围是 0-65535. 3. 目的地址传送指令. LEA 装入有效地址.例: LEA DX,string ;把偏移地址存到DX. LDS 传送目标指针,把指针内容装入DS.例: LDS SI,string ;把段地址:偏移地址存到DS:SI. LES 传送目标指针,把指针内容装入ES.例: LES DI,string ;把段地址:偏移地址存到ES:DI. LFS 传送目标指针,把指针内容装入FS.例: LFS DI,string ;把段地址:偏移地址存到FS:DI. LGS 传送目标指针,把指针内容装入GS.例: LGS DI,string ;把段地址:偏移地址存到GS:DI. LSS 传送目标指针,把指针内容装入SS.例: LSS DI,string ;把段地址:偏移地址存到SS:DI. 4. 标志传送指令. LAHF 标志寄存器传送,把标志装入AH. SAHF 标志寄存器传送,把AH内容装入标志寄存器. PUSHF 标志入栈. POPF 标志出栈. PUSHD 32位标志入栈. POPD 32位标志出栈. ---------- 二、算术运算指令 ---------------------------------------------------- ADD 加法. ADC 带进位加法. INC 加 1. AAA 加法的ASCII码调整. DAA 加法的十进制调整. SUB 减法. SBB 带借位减法. DEC 减 1. NEG 求反(以 0 减之). CMP 比较.(两操作数作减法,仅修改标志位,不回送结果). AAS 减法的ASCII码调整. DAS 减法的十进制调整. MUL 无符号乘法.结果回送AH和AL(字节运算),或DX和AX(字运算), IMUL 整数乘法.结果回送AH和AL(字节运算),或DX和AX(字运算), AAM 乘法的ASCII码调整. DIV 无符号除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算). IDIV 整数除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算). AAD 除法的ASCII码调整. CBW 字节转换为字. (把AL中字节的符号扩展到AH中去) CWD 字转换为双字. (把AX中的字的符号扩展到DX中去) CWDE 字转换为双字. (把AX中的字符号扩展到EAX中去) CDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去) ---------- 三、逻辑运算指令 ---------------------------------------------------- AND 与运算. OR 或运算. XOR 异或运算. NOT 取反. TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果). SHL 逻辑左移. SAL 算术左移.(=SHL) SHR 逻辑右移. SAR 算术右移.(=SHR) ROL 循环左移. ROR 循环右移. RCL 通过进位的循环左移. RCR 通过进位的循环右移. 以上八种移位指令,其移位次数可达255次. 移位一次时, 可直接用操作码. 如 SHL AX,1. 移位&gt;1次时, 则由寄存器CL给出移位次数. 如 MOV CL,04 SHL AX,CL ---------- 四、串指令 ---------------------------------------------------------- DS:SI 源串段寄存器 :源串变址. ES:DI 目标串段寄存器:目标串变址. CX 重复次数计数器. AL/AX 扫描值. D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量. Z标志 用来控制扫描或比较操作的结束. MOVS 串传送.( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. ) CMPS 串比较.( CMPSB 比较字符. CMPSW 比较字. ) SCAS 串扫描.把AL或AX的内容与目标串作比较,比较结果反映在标志位. LODS 装入串.把源串中的元素(字或字节)逐一装入AL或AX中.( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. ) STOS 保存串.是LODS的逆过程. REP 当CX/ECX&lt;&gt;0时重复. REPE/REPZ 当ZF=1或比较结果相等,且CX/ECX&lt;&gt;0时重复. REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX&lt;&gt;0时重复. REPC 当CF=1且CX/ECX&lt;&gt;0时重复. REPNC 当CF=0且CX/ECX&lt;&gt;0时重复. ---------- 五、程序转移指令 ---------------------------------------------------- 1. 无条件转移指令 (长转移) JMP 无条件转移指令 CALL 过程调用 RET/RETF 过程返回. 2. 条件转移指令 (短转移,-128到+127的距离内)( 当且仅当(SF XOR OF)=1时,OP1&lt;OP2 ) JA/JNBE 不小于或不等于时转移. JAE/JNB 大于或等于转移. JB/JNAE 小于转移. JBE/JNA 小于或等于转移. 以上四条,测试无符号整数运算的结果(标志C和Z). JG/JNLE 大于转移. JGE/JNL 大于或等于转移. JL/JNGE 小于转移. JLE/JNG 小于或等于转移. 以上四条,测试带符号整数运算的结果(标志S,O和Z). JE/JZ 等于转移. JNE/JNZ 不等于时转移. JC 有进位时转移. JNC 无进位时转移. JNO 不溢出时转移. JNP/JPO 奇偶性为奇数时转移. JNS 符号位为 &quot;0&quot; 时转移. JO 溢出转移. JP/JPE 奇偶性为偶数时转移. JS 符号位为 &quot;1&quot; 时转移. 3. 循环控制指令(短转移) LOOP CX不为零时循环. LOOPE/LOOPZ CX不为零且标志Z=1时循环. LOOPNE/LOOPNZ CX不为零且标志Z=0时循环. JCXZ CX为零时转移. JECXZ ECX为零时转移. 4. 中断指令 INT 中断指令 INTO 溢出中断 IRET 中断返回 5. 处理器控制指令 HLT 处理器暂停, 直到出现中断或复位信号才继续. WAIT 当芯片引线TEST为高电平时使CPU进入等待状态. ESC 转换到外处理器. LOCK 封锁总线. NOP 空操作. STC 置进位标志位. CLC 清进位标志位. CMC 进位标志取反. STD 置方向标志位. CLD 清方向标志位. STI 置中断允许位. CLI 清中断允许位. ---------- 六、伪指令 ---------------------------------------------------------- DW 定义字(2字节). PROC 定义过程. ENDP 过程结束. SEGMENT 定义段. ASSUME 建立段寄存器寻址. ENDS 段结束. END 程序结束. ---------- 七、处理机控制指令：标志处理指令 ------------------------------------ CLC 进位位置0指令 CMC 进位位求反指令 STC 进位位置为1指令 CLD 方向标志置1指令 STD 方向标志位置1指令 CLI 中断标志置0指令 STI 中断标志置1指令 NOP 无操作 HLT 停机 WAIT 等待 ESC 换码 LOCK 封锁 ========== 浮点运算指令集 ====================================================== ---------- 一、控制指令(带9B的控制指令前缀F变为FN时浮点不检查，机器码去掉9B)---- FINIT 初始化浮点部件 机器码 9B DB E3 FCLEX 清除异常 机器码 9B DB E2 FDISI 浮点检查禁止中断 机器码 9B DB E1 FENI 浮点检查禁止中断二 机器码 9B DB E0 WAIT 同步CPU和FPU 机器码 9B FWAIT 同步CPU和FPU 机器码 D9 D0 FNOP 无操作 机器码 DA E9 FXCH 交换ST(0)和ST(1) 机器码 D9 C9 FXCH ST(i) 交换ST(0)和ST(i) 机器码 D9 C1iii FSTSW ax 状态字到ax 机器码 9B DF E0 FSTSW word ptr mem 状态字到mem 机器码 9B DD mm111mmm FLDCW word ptr mem mem到状态字 机器码 D9 mm101mmm FSTCW word ptr mem 控制字到mem 机器码 9B D9 mm111mmm FLDENV word ptr mem mem到全环境 机器码 D9 mm100mmm FSTENV word ptr mem 全环境到mem 机器码 9B D9 mm110mmm FRSTOR word ptr mem mem到FPU状态 机器码 DD mm100mmm FSAVE word ptr mem FPU状态到mem 机器码 9B DD mm110mmm FFREE ST(i) 标志ST(i)未使用 机器码 DD C0iii FDECSTP 减少栈指针1-&gt;0 2-&gt;1 机器码 D9 F6 FINCSTP 增加栈指针0-&gt;1 1-&gt;2 机器码 D9 F7 FSETPM 浮点设置保护 机器码 DB E4 ---------- 二、数据传送指令 ---------------------------------------------------- FLDZ 将0.0装入ST(0) 机器码 D9 EE FLD1 将1.0装入ST(0) 机器码 D9 E8 FLDPI 将π装入ST(0) 机器码 D9 EB FLDL2T 将ln10/ln2装入ST(0) 机器码 D9 E9 FLDL2E 将1/ln2装入ST(0) 机器码 D9 EA FLDLG2 将ln2/ln10装入ST(0) 机器码 D9 EC FLDLN2 将ln2装入ST(0) 机器码 D9 ED FLD real4 ptr mem 装入mem的单精度浮点数 机器码 D9 mm000mmm FLD real8 ptr mem 装入mem的双精度浮点数 机器码 DD mm000mmm FLD real10 ptr mem 装入mem的十字节浮点数 机器码 DB mm101mmm FILD word ptr mem 装入mem的二字节整数 机器码 DF mm000mmm FILD dword ptr mem 装入mem的四字节整数 机器码 DB mm000mmm FILD qword ptr mem 装入mem的八字节整数 机器码 DF mm101mmm FBLD tbyte ptr mem 装入mem的十字节BCD数 机器码 DF mm100mmm FST real4 ptr mem 保存单精度浮点数到mem 机器码 D9 mm010mmm FST real8 ptr mem 保存双精度浮点数到mem 机器码 DD mm010mmm FIST word ptr mem 保存二字节整数到mem 机器码 DF mm010mmm FIST dword ptr mem 保存四字节整数到mem 机器码 DB mm010mmm FSTP real4 ptr mem 保存单精度浮点数到mem并出栈 机器码 D9 mm011mmm FSTP real8 ptr mem 保存双精度浮点数到mem并出栈 机器码 DD mm011mmm FSTP real10 ptr mem 保存十字节浮点数到mem并出栈 机器码 DB mm111mmm FISTP word ptr mem 保存二字节整数到mem并出栈 机器码 DF mm011mmm FISTP dword ptr mem 保存四字节整数到mem并出栈 机器码 DB mm011mmm FISTP qword ptr mem 保存八字节整数到mem并出栈 机器码 DF mm111mmm FBSTP tbyte ptr mem 保存十字节BCD数到mem并出栈 机器码 DF mm110mmm FCMOVB ST(0),ST(i) &lt;时传送 机器码 DA C0iii FCMOVBE ST(0),ST(i) &lt;=时传送 机器码 DA D0iii FCMOVE ST(0),ST(i) =时传送 机器码 DA C1iii FCMOVNB ST(0),ST(i) &gt;=时传送 机器码 DB C0iii FCMOVNBE ST(0),ST(i) &gt;时传送 机器码 DB D0iii FCMOVNE ST(0),ST(i) !=时传送 机器码 DB C1iii FCMOVNU ST(0),ST(i) 有序时传送 机器码 DB D1iii FCMOVU ST(0),ST(i) 无序时传送 机器码 DA D1iii ---------- 三、比较指令 -------------------------------------------------------- FCOM ST(0)-ST(1) 机器码 D8 D1 FCOMI ST(0),ST(i) ST(0)-ST(1) 机器码 DB F0iii FCOMIP ST(0),ST(i) ST(0)-ST(1)并出栈 机器码 DF F0iii FCOM real4 ptr mem ST(0)-实数mem 机器码 D8 mm010mmm FCOM real8 ptr mem ST(0)-实数mem 机器码 DC mm010mmm FICOM word ptr mem ST(0)-整数mem 机器码 DE mm010mmm FICOM dword ptr mem ST(0)-整数mem 机器码 DA mm010mmm FICOMP word ptr mem ST(0)-整数mem并出栈 机器码 DE mm011mmm FICOMP dword ptr mem ST(0)-整数mem并出栈 机器码 DA mm011mmm FTST ST(0)-0 机器码 D9 E4 FUCOM ST(i) ST(0)-ST(i) 机器码 DD E0iii FUCOMP ST(i) ST(0)-ST(i)并出栈 机器码 DD E1iii FUCOMPP ST(0)-ST(1)并二次出栈 机器码 DA E9 FXAM ST(0)规格类型 机器码 D9 E5 ---------- 四、运算指令 -------------------------------------------------------- FADD 把目的操作数 (直接接在指令后的变量或堆栈缓存器) 与来源操作数 (接在目的操作数后的变量或堆栈缓存器) 相加，并将结果存入目的操作数 FADDP ST(i),ST 这个指令是使目的操作数加上 ST 缓存器，并弹出 ST 缓存器，而目的操作数必须是堆栈缓存器的其中之一，最后不管目的操作数为何，经弹出一次后，目的操作数会变成上一个堆栈缓存器了 FIADD FIADD 是把 ST 加上来源操作数，然后再存入 ST 缓存器，来源操作数必须是字组整数或短整数形态的变数 FSUB 减 FSUBP FSUBR 减数与被减数互换 FSUBRP FISUB FISUBR FMUL 乘 FMULP FIMUL FDIV 除 FDIVP FDIVR FDIVRP FIDIV FIDIVR FCHS 改变 ST 的正负值 FABS 把 ST 之值取出，取其绝对值后再存回去。 FSQRT 将 ST 之值取出，开根号后再存回去。 FSCALE 这个指令是计算 ST*2^ST(1)之值，再把结果存入 ST 里而 ST(1) 之值不变。ST(1) 必须是在 -32768 到 32768 (-215 到 215 )之间的整数，如果超过这个范围计算结果无法确定，如果不是整数 ST(1) 会先向零舍入成整数再计算。所以为安全起见，最好是由字组整数载入到 ST(1) 里。 FRNDINT 这个指令是把 ST 的数值舍入成整数，FPU 提供四种舍入方式，由 FPU 的控制字组(control word)中的 RC 两个位决定 RC 舍入控制 00 四舍五入 01 向负无限大舍入 10 向正无限大舍入 11 向零舍去 ================================================================================","link":"/2019/10/16/汇编/"}],"tags":[{"name":"github","slug":"github","link":"/tags/github/"},{"name":"idea","slug":"idea","link":"/tags/idea/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"hello world","slug":"hello-world","link":"/tags/hello-world/"},{"name":"swing","slug":"swing","link":"/tags/swing/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"连接池","slug":"连接池","link":"/tags/连接池/"},{"name":"云主机","slug":"云主机","link":"/tags/云主机/"},{"name":"汇编语言","slug":"汇编语言","link":"/tags/汇编语言/"}],"categories":[{"name":"技巧","slug":"技巧","link":"/categories/技巧/"},{"name":"学习","slug":"学习","link":"/categories/学习/"}]}